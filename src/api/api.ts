/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI Orklas
 * This is an api spec for room reservation program.
 *
 * The version of the OpenAPI document: 1.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Describes the result of uploading an image resource
 */
export interface ApiResponse {
    'code'?: number;
    'type'?: string;
    'message'?: string;
}
export interface LoginRequest {
    'username': string;
    'password': string;
}
export interface LoginResponse {
    'accessToken'?: string;
    'tokenType'?: string;
    /**
     * Token lifetime in seconds
     */
    'expiresIn'?: number;
}
export interface Reservation {
    'id': number;
    'schedId': number;
    'userId': number;
    'status': ReservationStatus;
    'description'?: string;
    'date': string;
    'createdAt': string;
}


export interface ReservationCreate {
    'schedId': number;
    'description'?: string;
    'date': string;
}
export interface ReservationListResponse {
    'items': Array<Reservation>;
    'total': number;
}

export const ReservationStatus = {
    Waiting: 'waiting',
    Accepted: 'accepted',
    Denied: 'denied'
} as const;

export type ReservationStatus = typeof ReservationStatus[keyof typeof ReservationStatus];


export interface ReservationStatusUpdate {
    'status': ReservationStatusUpdateStatusEnum;
}

export const ReservationStatusUpdateStatusEnum = {
    Accepted: 'accepted',
    Denied: 'denied'
} as const;

export type ReservationStatusUpdateStatusEnum = typeof ReservationStatusUpdateStatusEnum[keyof typeof ReservationStatusUpdateStatusEnum];

/**
 * A reservable room
 */
export interface Room {
    'id': number;
    'name': string;
    'status': RoomStatus;
    'roomType': RoomType;
    'photoUrls': Array<string>;
    'tagIds': Array<number>;
}


export interface RoomCreate {
    'name': string;
    'roomType': RoomType;
    'tagIds': Array<number>;
}


export interface RoomImage {
    'id'?: number;
    'url'?: string;
}
export interface RoomListResponse {
    'items': Array<Room>;
    'total': number;
}
/**
 * Status describes availablity of a room, wheter it\'s available to use, reserve, or neither
 */

export const RoomStatus = {
    Reserved: 'reserved',
    Closed: 'closed',
    Open: 'open'
} as const;

export type RoomStatus = typeof RoomStatus[keyof typeof RoomStatus];


/**
 * Yes, it\'s a type of a room
 */

export const RoomType = {
    Class: 'class',
    Laboratory: 'laboratory',
    Theater: 'theater'
} as const;

export type RoomType = typeof RoomType[keyof typeof RoomType];


export interface RoomUpdate {
    'name'?: string;
    'status'?: RoomStatus;
    'roomType'?: RoomType;
    'tagIds'?: Array<number>;
}


export interface Schedule {
    'id': number;
    'roomId': number;
    'startTime': string;
    'endTime': string;
    'isReserved': boolean;
}
export interface ScheduleCreate {
    'startTime': string;
    'endTime': string;
}
/**
 * A tag for a room
 */
export interface Tag {
    'id'?: number;
    'name'?: string;
    'description'?: string;
}
/**
 * A User who is reserving/managing rooms
 */
export interface User {
    'id'?: number;
    'username'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'email'?: string;
    'password'?: string;
    'phone'?: string;
    /**
     * User Status
     */
    'userStatus'?: number;
    'role'?: UserRole;
}


export interface UserCreate {
    'username': string;
    'email': string;
    'password': string;
    'firstName'?: string;
    'lastName'?: string;
    'phone'?: string;
}
export interface UserCreateSpecial {
    'username': string;
    'email': string;
    'password': string;
    'firstName'?: string;
    'lastName'?: string;
    'phone'?: string;
    'role': UserRole;
}


export interface UserResponse {
    'id'?: number;
    'username'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'email'?: string;
    'phone'?: string;
    'userStatus'?: number;
}
/**
 * Role is used to define authority of a user
 */

export const UserRole = {
    Student: 'student',
    Lecturer: 'lecturer',
    Administrator: 'administrator'
} as const;

export type UserRole = typeof UserRole[keyof typeof UserRole];


export interface UserUpdate {
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'phone'?: string;
}

/**
 * ReservationApi - axios parameter creator
 */
export const ReservationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Only allowed for owner while status is waiting
         * @summary Cancel reservation
         * @param {number} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReservation: async (reservationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('cancelReservation', 'reservationId', reservationId)
            const localVarPath = `/reservations/{reservationId}`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a reservation for a room schedule
         * @summary Create reservation
         * @param {ReservationCreate} reservationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReservation: async (reservationCreate: ReservationCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationCreate' is not null or undefined
            assertParamExists('createReservation', 'reservationCreate', reservationCreate)
            const localVarPath = `/reservations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reservationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List active and future reservations of the authenticated user
         * @summary List user reservations
         * @param {ReservationStatus} [status] 
         * @param {string} [from] Filter reservations starting from this date
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyReservations: async (status?: ReservationStatus, from?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reservations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all reservation
         * @summary List all reservation
         * @param {Array<ReservationStatus>} [status] Status of reservation
         * @param {string} [from] Filter reservations starting from this time
         * @param {string} [to] Filter reservations starting to this time
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReservationAll: async (status?: Array<ReservationStatus>, from?: string, to?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reservations/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReservationApi - functional programming interface
 */
export const ReservationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReservationApiAxiosParamCreator(configuration)
    return {
        /**
         * Only allowed for owner while status is waiting
         * @summary Cancel reservation
         * @param {number} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelReservation(reservationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelReservation(reservationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationApi.cancelReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request a reservation for a room schedule
         * @summary Create reservation
         * @param {ReservationCreate} reservationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReservation(reservationCreate: ReservationCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReservation(reservationCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationApi.createReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List active and future reservations of the authenticated user
         * @summary List user reservations
         * @param {ReservationStatus} [status] 
         * @param {string} [from] Filter reservations starting from this date
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyReservations(status?: ReservationStatus, from?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyReservations(status, from, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationApi.listMyReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all reservation
         * @summary List all reservation
         * @param {Array<ReservationStatus>} [status] Status of reservation
         * @param {string} [from] Filter reservations starting from this time
         * @param {string} [to] Filter reservations starting to this time
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReservationAll(status?: Array<ReservationStatus>, from?: string, to?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReservationAll(status, from, to, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationApi.listReservationAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReservationApi - factory interface
 */
export const ReservationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReservationApiFp(configuration)
    return {
        /**
         * Only allowed for owner while status is waiting
         * @summary Cancel reservation
         * @param {number} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReservation(reservationId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelReservation(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a reservation for a room schedule
         * @summary Create reservation
         * @param {ReservationCreate} reservationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReservation(reservationCreate: ReservationCreate, options?: RawAxiosRequestConfig): AxiosPromise<Reservation> {
            return localVarFp.createReservation(reservationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List active and future reservations of the authenticated user
         * @summary List user reservations
         * @param {ReservationStatus} [status] 
         * @param {string} [from] Filter reservations starting from this date
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyReservations(status?: ReservationStatus, from?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ReservationListResponse> {
            return localVarFp.listMyReservations(status, from, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * List all reservation
         * @summary List all reservation
         * @param {Array<ReservationStatus>} [status] Status of reservation
         * @param {string} [from] Filter reservations starting from this time
         * @param {string} [to] Filter reservations starting to this time
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReservationAll(status?: Array<ReservationStatus>, from?: string, to?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ReservationListResponse> {
            return localVarFp.listReservationAll(status, from, to, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReservationApi - object-oriented interface
 */
export class ReservationApi extends BaseAPI {
    /**
     * Only allowed for owner while status is waiting
     * @summary Cancel reservation
     * @param {number} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelReservation(reservationId: number, options?: RawAxiosRequestConfig) {
        return ReservationApiFp(this.configuration).cancelReservation(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a reservation for a room schedule
     * @summary Create reservation
     * @param {ReservationCreate} reservationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createReservation(reservationCreate: ReservationCreate, options?: RawAxiosRequestConfig) {
        return ReservationApiFp(this.configuration).createReservation(reservationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List active and future reservations of the authenticated user
     * @summary List user reservations
     * @param {ReservationStatus} [status] 
     * @param {string} [from] Filter reservations starting from this date
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMyReservations(status?: ReservationStatus, from?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ReservationApiFp(this.configuration).listMyReservations(status, from, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all reservation
     * @summary List all reservation
     * @param {Array<ReservationStatus>} [status] Status of reservation
     * @param {string} [from] Filter reservations starting from this time
     * @param {string} [to] Filter reservations starting to this time
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listReservationAll(status?: Array<ReservationStatus>, from?: string, to?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ReservationApiFp(this.configuration).listReservationAll(status, from, to, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReservationAdminApi - axios parameter creator
 */
export const ReservationAdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept or deny a reservation (admin only)
         * @summary Update reservation status
         * @param {number} reservationId 
         * @param {ReservationStatusUpdate} reservationStatusUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReservationStatus: async (reservationId: number, reservationStatusUpdate: ReservationStatusUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('updateReservationStatus', 'reservationId', reservationId)
            // verify required parameter 'reservationStatusUpdate' is not null or undefined
            assertParamExists('updateReservationStatus', 'reservationStatusUpdate', reservationStatusUpdate)
            const localVarPath = `/reservations/{reservationId}/status`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reservationStatusUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReservationAdminApi - functional programming interface
 */
export const ReservationAdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReservationAdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept or deny a reservation (admin only)
         * @summary Update reservation status
         * @param {number} reservationId 
         * @param {ReservationStatusUpdate} reservationStatusUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReservationStatus(reservationId: number, reservationStatusUpdate: ReservationStatusUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReservationStatus(reservationId, reservationStatusUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationAdminApi.updateReservationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReservationAdminApi - factory interface
 */
export const ReservationAdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReservationAdminApiFp(configuration)
    return {
        /**
         * Accept or deny a reservation (admin only)
         * @summary Update reservation status
         * @param {number} reservationId 
         * @param {ReservationStatusUpdate} reservationStatusUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReservationStatus(reservationId: number, reservationStatusUpdate: ReservationStatusUpdate, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateReservationStatus(reservationId, reservationStatusUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReservationAdminApi - object-oriented interface
 */
export class ReservationAdminApi extends BaseAPI {
    /**
     * Accept or deny a reservation (admin only)
     * @summary Update reservation status
     * @param {number} reservationId 
     * @param {ReservationStatusUpdate} reservationStatusUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateReservationStatus(reservationId: number, reservationStatusUpdate: ReservationStatusUpdate, options?: RawAxiosRequestConfig) {
        return ReservationAdminApiFp(this.configuration).updateReservationStatus(reservationId, reservationStatusUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomApi - axios parameter creator
 */
export const RoomApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new room
         * @param {RoomCreate} roomCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom: async (roomCreate: RoomCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomCreate' is not null or undefined
            assertParamExists('createRoom', 'roomCreate', roomCreate)
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a room
         * @param {number} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom: async (roomId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteRoom', 'roomId', roomId)
            const localVarPath = `/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room by ID
         * @param {number} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById: async (roomId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getRoomById', 'roomId', roomId)
            const localVarPath = `/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List rooms with optional filters, pagination, and sorting
         * @summary List rooms
         * @param {Array<RoomStatus>} [status] 
         * @param {Array<number>} [tagIds] 
         * @param {RoomType} [roomType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sort] Sort by field (prefix with - for descending)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRooms: async (status?: Array<RoomStatus>, tagIds?: Array<number>, roomType?: RoomType, limit?: number, offset?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS.csv);
            }

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds.join(COLLECTION_FORMATS.csv);
            }

            if (roomType !== undefined) {
                localVarQueryParameter['roomType'] = roomType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update room fields
         * @param {number} roomId 
         * @param {RoomUpdate} roomUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoom: async (roomId: number, roomUpdate: RoomUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updateRoom', 'roomId', roomId)
            // verify required parameter 'roomUpdate' is not null or undefined
            assertParamExists('updateRoom', 'roomUpdate', roomUpdate)
            const localVarPath = `/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload room image
         * @param {number} roomId 
         * @param {File} file 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRoomImage: async (roomId: number, file: File, description?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('uploadRoomImage', 'roomId', roomId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadRoomImage', 'file', file)
            const localVarPath = `/rooms/{roomId}/images`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomApi - functional programming interface
 */
export const RoomApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new room
         * @param {RoomCreate} roomCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoom(roomCreate: RoomCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoom(roomCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomApi.createRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a room
         * @param {number} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoom(roomId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoom(roomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomApi.deleteRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room by ID
         * @param {number} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomById(roomId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomById(roomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomApi.getRoomById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List rooms with optional filters, pagination, and sorting
         * @summary List rooms
         * @param {Array<RoomStatus>} [status] 
         * @param {Array<number>} [tagIds] 
         * @param {RoomType} [roomType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sort] Sort by field (prefix with - for descending)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRooms(status?: Array<RoomStatus>, tagIds?: Array<number>, roomType?: RoomType, limit?: number, offset?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRooms(status, tagIds, roomType, limit, offset, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomApi.listRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update room fields
         * @param {number} roomId 
         * @param {RoomUpdate} roomUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoom(roomId: number, roomUpdate: RoomUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoom(roomId, roomUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomApi.updateRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload room image
         * @param {number} roomId 
         * @param {File} file 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRoomImage(roomId: number, file: File, description?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRoomImage(roomId, file, description, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomApi.uploadRoomImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomApi - factory interface
 */
export const RoomApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new room
         * @param {RoomCreate} roomCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom(roomCreate: RoomCreate, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
            return localVarFp.createRoom(roomCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a room
         * @param {number} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom(roomId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room by ID
         * @param {number} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById(roomId: number, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
            return localVarFp.getRoomById(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * List rooms with optional filters, pagination, and sorting
         * @summary List rooms
         * @param {Array<RoomStatus>} [status] 
         * @param {Array<number>} [tagIds] 
         * @param {RoomType} [roomType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sort] Sort by field (prefix with - for descending)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRooms(status?: Array<RoomStatus>, tagIds?: Array<number>, roomType?: RoomType, limit?: number, offset?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomListResponse> {
            return localVarFp.listRooms(status, tagIds, roomType, limit, offset, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update room fields
         * @param {number} roomId 
         * @param {RoomUpdate} roomUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoom(roomId: number, roomUpdate: RoomUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
            return localVarFp.updateRoom(roomId, roomUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload room image
         * @param {number} roomId 
         * @param {File} file 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRoomImage(roomId: number, file: File, description?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomImage> {
            return localVarFp.uploadRoomImage(roomId, file, description, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomApi - object-oriented interface
 */
export class RoomApi extends BaseAPI {
    /**
     * 
     * @summary Create a new room
     * @param {RoomCreate} roomCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRoom(roomCreate: RoomCreate, options?: RawAxiosRequestConfig) {
        return RoomApiFp(this.configuration).createRoom(roomCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a room
     * @param {number} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRoom(roomId: number, options?: RawAxiosRequestConfig) {
        return RoomApiFp(this.configuration).deleteRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room by ID
     * @param {number} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRoomById(roomId: number, options?: RawAxiosRequestConfig) {
        return RoomApiFp(this.configuration).getRoomById(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List rooms with optional filters, pagination, and sorting
     * @summary List rooms
     * @param {Array<RoomStatus>} [status] 
     * @param {Array<number>} [tagIds] 
     * @param {RoomType} [roomType] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sort] Sort by field (prefix with - for descending)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRooms(status?: Array<RoomStatus>, tagIds?: Array<number>, roomType?: RoomType, limit?: number, offset?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return RoomApiFp(this.configuration).listRooms(status, tagIds, roomType, limit, offset, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update room fields
     * @param {number} roomId 
     * @param {RoomUpdate} roomUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRoom(roomId: number, roomUpdate: RoomUpdate, options?: RawAxiosRequestConfig) {
        return RoomApiFp(this.configuration).updateRoom(roomId, roomUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload room image
     * @param {number} roomId 
     * @param {File} file 
     * @param {string} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadRoomImage(roomId: number, file: File, description?: string, options?: RawAxiosRequestConfig) {
        return RoomApiFp(this.configuration).uploadRoomImage(roomId, file, description, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScheduleApi - axios parameter creator
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create room schedule
         * @param {number} roomId 
         * @param {ScheduleCreate} scheduleCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule: async (roomId: number, scheduleCreate: ScheduleCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createSchedule', 'roomId', roomId)
            // verify required parameter 'scheduleCreate' is not null or undefined
            assertParamExists('createSchedule', 'scheduleCreate', scheduleCreate)
            const localVarPath = `/rooms/{roomId}/schedules`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cannot delete schedule with accepted reservations
         * @summary Delete schedule
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule: async (scheduleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('deleteSchedule', 'scheduleId', scheduleId)
            const localVarPath = `/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Includes availability info
         * @summary List room schedules
         * @param {number} roomId 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomSchedules: async (roomId: number, from?: string, to?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listRoomSchedules', 'roomId', roomId)
            const localVarPath = `/rooms/{roomId}/schedules`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List schedules for all rooms
         * @summary List all schedules
         * @param {boolean} [status] Status of schedule, reserved or not
         * @param {string} [from] Filter reservations starting from this time
         * @param {string} [to] Filter reservations starting to this time
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchedules: async (status?: boolean, from?: string, to?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create room schedule
         * @param {number} roomId 
         * @param {ScheduleCreate} scheduleCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchedule(roomId: number, scheduleCreate: ScheduleCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchedule(roomId, scheduleCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.createSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cannot delete schedule with accepted reservations
         * @summary Delete schedule
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchedule(scheduleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchedule(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.deleteSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Includes availability info
         * @summary List room schedules
         * @param {number} roomId 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoomSchedules(roomId: number, from?: string, to?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoomSchedules(roomId, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.listRoomSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List schedules for all rooms
         * @summary List all schedules
         * @param {boolean} [status] Status of schedule, reserved or not
         * @param {string} [from] Filter reservations starting from this time
         * @param {string} [to] Filter reservations starting to this time
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchedules(status?: boolean, from?: string, to?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchedules(status, from, to, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.listSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScheduleApi - factory interface
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create room schedule
         * @param {number} roomId 
         * @param {ScheduleCreate} scheduleCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule(roomId: number, scheduleCreate: ScheduleCreate, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createSchedule(roomId, scheduleCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Cannot delete schedule with accepted reservations
         * @summary Delete schedule
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule(scheduleId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSchedule(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Includes availability info
         * @summary List room schedules
         * @param {number} roomId 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomSchedules(roomId: number, from?: string, to?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Schedule>> {
            return localVarFp.listRoomSchedules(roomId, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * List schedules for all rooms
         * @summary List all schedules
         * @param {boolean} [status] Status of schedule, reserved or not
         * @param {string} [from] Filter reservations starting from this time
         * @param {string} [to] Filter reservations starting to this time
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchedules(status?: boolean, from?: string, to?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Schedule>> {
            return localVarFp.listSchedules(status, from, to, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 */
export class ScheduleApi extends BaseAPI {
    /**
     * 
     * @summary Create room schedule
     * @param {number} roomId 
     * @param {ScheduleCreate} scheduleCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSchedule(roomId: number, scheduleCreate: ScheduleCreate, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).createSchedule(roomId, scheduleCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cannot delete schedule with accepted reservations
     * @summary Delete schedule
     * @param {number} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSchedule(scheduleId: number, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).deleteSchedule(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Includes availability info
     * @summary List room schedules
     * @param {number} roomId 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRoomSchedules(roomId: number, from?: string, to?: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).listRoomSchedules(roomId, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List schedules for all rooms
     * @summary List all schedules
     * @param {boolean} [status] Status of schedule, reserved or not
     * @param {string} [from] Filter reservations starting from this time
     * @param {string} [to] Filter reservations starting to this time
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSchedules(status?: boolean, from?: string, to?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).listSchedules(status, from, to, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new user
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreate: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createUser', 'userCreate', userCreate)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user with role support
         * @param {UserCreateSpecial} userCreateSpecial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSpecial: async (userCreateSpecial: UserCreateSpecial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateSpecial' is not null or undefined
            assertParamExists('createUserSpecial', 'userCreateSpecial', userCreateSpecial)
            const localVarPath = `/users/special`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateSpecial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginUser', 'loginRequest', loginRequest)
            const localVarPath = `/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Client should discard the JWT. Server may optionally blacklist token. 
         * @summary Logout current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {number} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateUser', 'userUpdate', userUpdate)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication klas_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new user
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user with role support
         * @param {UserCreateSpecial} userCreateSpecial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserSpecial(userCreateSpecial: UserCreateSpecial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserSpecial(userCreateSpecial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createUserSpecial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete user
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Authenticate user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Client should discard the JWT. Server may optionally blacklist token. 
         * @summary Logout current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.logoutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user
         * @param {number} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new user
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.createUser(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user with role support
         * @param {UserCreateSpecial} userCreateSpecial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSpecial(userCreateSpecial: UserCreateSpecial, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.createUserSpecial(userCreateSpecial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.loginUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Client should discard the JWT. Server may optionally blacklist token. 
         * @summary Logout current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {number} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.updateUser(id, userUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Register a new user
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user with role support
     * @param {UserCreateSpecial} userCreateSpecial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUserSpecial(userCreateSpecial: UserCreateSpecial, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createUserSpecial(userCreateSpecial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(id: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate user
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).loginUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Client should discard the JWT. Server may optionally blacklist token. 
     * @summary Logout current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutUser(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {number} id 
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUser(id: number, userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(id, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



